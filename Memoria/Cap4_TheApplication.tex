
% ---------------------------------------------------
%
% Trabajo de Fin de Grado. 
% Author: Alejandro Hernández Padrón. 
% Capítulo: La aplicación \ULLAR{}. 
% Fichero: Cap4_TheApplication.tex
%
% ----------------------------------------------------
%

\lstset{stringstyle=\color{purple}}
\chapter{La aplicación \ULLAR{}} \label{chap:LaAplicacion} 

En este capítulo se explicará en detalle la aplicación \ULLAR{} utilizando su especificación de requisitos y explicando su funcionamiento.

\section{Requisitos y ventanas de la aplicación} % (fold)

\ULLAR{} es una aplicación para dispositivos móviles, más concretamente, para dispositivos que utilizan Android como sistema operativo. Se trata de una aplicación diseñada para la comunidad de la Universidad de La Laguna, la cual permita a sus usuarios ubicarse, detectar y reconocer las instalaciones y edificios pertenecientes a la universidad, mediante técnicas de realidad aumentada basadas en la geolocalización.
La aplicación contempla diverso tipo de ubicaciones universitarias (facultades, bibliotecas, cafeterías, instalaciones deportivas, etc.). De forma genérica nos referiremos a las mismas como ``instalaciones''.

Los requisitos principales de \ULLAR{} son:
\begin{itemize}
    \item La aplicación se desarrollará para dispositivos con Android. Se utilizará Android Studio como IDE para su desarrollo.
    \item Se implementarán técnicas de realidad aumentada basadas en la geolocalización para mostrar al usuario la instalación de la ULL a la cual apunte con la cámara del dispositivo.
    \item Las instalaciones de la ULL, junto a su información correspondiente, estarán ubicadas en un base datos en la nube. El servidor que se conecte con esta base de datos también deberá estar en la nube.
\end{itemize}

\subsection{Especificación detallada de los requisitos} 

La aplicación se iniciará una ``Splash Screen'' \cite{URL::SplashScreen} o pantalla de inicio con el logo de la Universidad de La Laguna. Esta pantalla dará paso a una ventana de \textit{Inicio de sesión}.

Para poder utilizar \ULLAR{}, el usuario ha de poseer una cuenta de correo institucional de la ULL. Este correo ha de tratarse de una cuenta de GSuite \cite{URL::gsuite} de Google con el formato: ``\textit{@ull.edu.es}''. Sin ella no se podrá acceder a la aplicación.

Una vez autentificado con éxito, se accederá a una ventana de \textit{Inicio} en la que aparecerá un acceso directo a las ventanas de \textit{Mapa ULL} y \textit{Navegación en modo RA} que se  explicará más adelante. A su vez, dispondrá de accesos a enlaces web de interés de la ULL que se abrirán en un navegador externo. 

\ULLAR{} contará con un menú para moverse por las diferentes ventanas de la aplicación. Se implementará un menú deslizante lateral o \textit{Navigation Drawer} \cite{URL::NavigationDraw} ubicado en la parte superior izquierda de la aplicación. Este menú deberá ser simple e intuitivo.

Como accesos en este menú se dispone de las siguientes ventanas o funcionalidades:

\begin{itemize}
    \item Inicio: Ventana principal de la aplicación.
    \item Mapa ULL: Esta ventana contendrá un mapa de la ULL con todas las instalaciones en la base de datos.
    \item Navegación en modo RA: En esta ventana, mediante el uso de la cámara, se identificarán las instalaciones de la ULL a las que el usuario apunte con el dispositivo y permitirá mostrar una ventana con información detallada de las mismas.
    \item Todas las instalaciones ULL: Contiene todas las ubicaciones e instalaciones de la ULL y permitirá al usuario realizar una búsqueda de estas. 
    \item Configuración: Permitirá acceder a los ajustes de la aplicación.
    \item Cerrar cesión: Cerrará la sesión actual y devolverá al usuario a la ventana de \textit{Inicio de sesión}.
    \item Info: Información de la aplicación y de su autor.
\end{itemize}

Cada instalación de la universidad tendrá una ficha de información que será accesible desde una ventana de la aplicación con la siguiente información:

\begin{itemize}
    \item \textbf{Id}: Campo para identificar la instalación.
    \item \textbf{Nombre}: Nombre oficial de la instalación.
    \item \textbf{Ubicación}: La ubicación exacta en la que se encuentra la instalación. 
    \item \textbf{Descripción}: Descripción de la instalación con el objetivo de esta y actividades que se desarrollan en ella.
    \item \textbf{Imagen}: Enlace URL de la imagen de la instalación.
    \item \textbf{Lista de enlaces de interés}: Una lista con los enlaces a las instituciones, servicios, departamentos y titulaciones asociadas con esta instalación.
\end{itemize}

Esta información estará guardada en una base de datos en la nube. Para acceder a esta, se dispondrá de un servidor en la nube que conecte con la base de datos y envié la información a la aplicación.

\subsection{Ventanas de la aplicación}

 

% \begin{figure}[h]
% \hspace*{\fill}%
% \begin{subfigure}[h]{0.32\linewidth}
% \includegraphics[width=\linewidth]{splashApp}
% \caption{Splash-Screen.}
% \label{fig:splashApp}
% \end{subfigure}
% \hfill%
% \begin{subfigure}[h]{0.32\linewidth}
% \includegraphics[width=\linewidth]{loginApp}
% \caption{Login.}
% \label{fig:loginApp} 
% \end{subfigure}%
% \caption{Ventanas de iniciales de \textit{\ULLAR{}}.}
% \hspace*{\fill}%
% \end{figure}
  
Al iniciar \ULLAR{}, la primera ventana que aparece es la pantalla de inicio o Splash Screen. Tras unos segundos, se carga la ventana de \textit{Inicio de sesión}. Para poder autentificarse el usuario debe poseer una cuenta de correo institucional de la ULL. Se dispondrá de un botón en el centro de la pantalla, que abrirá un cuadro de diálogo en el que poder introducir el correo y contraseña de esta cuenta.
  
\begin{figure}[h]
    \hspace*{\fill}%
    \begin{subfigure}[h]{0.35\linewidth}
    \includegraphics[width=\linewidth]{homeApp}
    \caption{Inicio.}
    \label{fig:homeApp}
    \end{subfigure} 
    \hfill%
    \begin{subfigure}[h]{0.35\linewidth}
    \includegraphics[width=\linewidth]{menuApp}
    \caption{Menu. Navigation Drawer.}
    \label{fig:menuApp}
    \end{subfigure}
    \caption{Ventana \textit{Inicio} y el \textit{Menú} de \textit{\ULLAR{}}.}
    \hspace*{\fill}
\end{figure}

Cuando el usuario consiga autentificarse con éxito, se abrirá la ventana de \textit{Inicio} (véase Figura \ref{fig:homeApp}). En esta aparecerá una lista de accesos directos a las funcionalidades principales de \ULLAR{}, como son \textit{Navegación en modo RA} y \textit{Mapa ULL}, y una serie de enlaces a sitios web relacionados con la ULL.

En la esquina superior izquierda de \ULLAR{} se encuentra situado el botón de acceso al menú \textit{Navigation Drawer}. Si se presiona se desplegará el menú que permite al usuario moverse por las distintas ventanas de la aplicación (véase Figura \ref{fig:menuApp}).

Si el usuario se desplaza a la ventana de \textit{Mapa ULL} (véase Figura \ref{fig:mapsApp}) encontrará el mapa generado por la API de Google Maps. En este mapa aparecerán con pines azules las instalaciones de la ULL que están guardadas en la base de datos. Cuando el GPS del dispositivo encuentre la ubicación actual, aparecerá un pin rojo que indicará su posición en el mapa. En la parte inferior y en el centro de la ventana, se dispone de un botón llamado ``AR Mode'' que permite acceder a la ventana de \textit{Navegación en modo RA}.
  
\begin{figure}[h]
    \hspace*{\fill}%
    \begin{subfigure}[h]{0.37\linewidth}
        \includegraphics[width=\linewidth]{mapsApp}
        \caption{Mapa ULL.}
        \label{fig:mapsApp}
    \end{subfigure}
    \hfill%
    \begin{subfigure}[h]{0.37\linewidth}
        \includegraphics[width=\linewidth]{menuApp}
        \caption{Ventana de \textit{Inicio}}
        \label{fig:menussApp}
    \end{subfigure}%
    \caption{Ventana Inicio y menú de \textit{\ULLAR{}}}
    \hspace*{\fill}%
\end{figure}

% \begin{figure}[h]
%     \centering
%     \includegraphics[width=0.38\linewidth]{mapsApp}
%     \caption{Mapa ULL.}
%     \label{fig:mapsApp}
% \end{figure}

En la ventana de \textit{Navegación en modo RA} se mostrará la imagen obtenida de la cámara del dispositivo. Con ella el usuario podrá ver en la pantalla la instalación a la que apunte con el dispositivo. Encima de esta imagen se mostrará un texto en el que aparecerán dos mensajes: uno informativo para indicar al usuario que apunte a alguna instalación de la ULL y una vez que el usuario se encuentre apuntando a una instalación, el mensaje anterior se cambiará por el nombre de la instalación y, al mismo tiempo, aparecerá un pequeño botón debajo del texto que llevará al usuario a la ventana de \textit{Información de la instalación} (véase Figura \ref{fig:siteInfoApp}), con la información de dicha instalación. Por último, en la parte inferior se mostrará un botón que indicará si se han encontrado más instalaciones aparte de la que se muestra en la parte superior. Este botón permitirá acceder a una ventana con una lista de estas instalaciones.

 
\begin{figure}[h]
    \hspace*{\fill}%
    \begin{subfigure}[h]{0.37\linewidth}
    \includegraphics[width=\linewidth]{allSitesApp}
    \caption{Todas las instalaciones ULL.}
    \label{fig:allSitesApp}
    \end{subfigure}
    \hfill%
    \begin{subfigure}[h]{0.37\linewidth}
    \includegraphics[width=\linewidth]{siteInfoApp}
    \caption{Información de la instalación.}
    \label{fig:siteInfoApp}
    \end{subfigure}%
    \caption{Ventanas de \textit{Todas las instalaciones ULL} e \textit{Información de la instalación} de \textit{\ULLAR{}}.}
    \hspace*{\fill}%
\end{figure}
\bigskip

A través del menú de la aplicación se puede acceder a la ventana de \textit{Todas las instalaciones ULL} (véase Figura \ref{fig:allSitesApp}). Aquí se mostrarán todas las instalaciones de la ULL que se encuentran en la base de datos. Además, se podrá hacer una búsqueda de cualquier instalación en la barra superior de la aplicación. Si se selecciona cualquiera de estas instalaciones se  desplegará una ventana con la información detallada de la instalación.


En la ventana \textit{Información de la instalación} (véase Figura \ref{fig:siteInfoApp}) se dispondrá la información perteneciente a cada instalación. Aquí se  mostrará una imagen de ésta, nombre y descripción de la instalación y una lista de enlaces con los servicios, secretarías, titulaciones y departamentos asociadas con la misma. 
Se dispone de un botón en la parte inferior de la imagen de la instalación, que  abrirá la ruta a su ubicación en la aplicación de Google Maps para permitir al usuario llegar a ella.  

Por último, desde el menú se podrá acceder a las dos últimas ventanas de la aplicación. Estas son la ventana \textit{Configuración} y la ventana \textit{Información}.

En la ventana de \textit{Configuración} (véase Figura \ref{fig:settingsApp}) se encuentran los ajustes de la aplicación. En ella se permite al usuario decidir si desea realizar una búsqueda, en la ventana de \textit{Mapas} y de \textit{Navegación en modo RA}, de las instalaciones que se encuentran en el área entre dos circunferencias. El centro de estas circunferencias será la ubicación actual del dispositivo.

La ventana \textit{Información} (véase Figura \ref{fig:infoApp})  muestra información básica de la aplicación como el nombre, versión, correo de contacto, autor y objetivo e información del desarrollo de la aplicación \textit{\ULLAR{}}.  

\begin{figure}[h]
    \hspace*{\fill}%
    \begin{subfigure}[h]{0.35\linewidth}
    \includegraphics[width=\linewidth]{settingsApp}
    \caption{Configuración.}
    \label{fig:settingsApp}
    \end{subfigure}
    \hfill%
    \begin{subfigure}[h]{0.35\linewidth}
    \includegraphics[width=\linewidth]{infoApp}
    \caption{Información.}
    \label{fig:infoApp}
    \end{subfigure}%
    \caption{Ventanas de \textit{Configuración} e \textit{Información} de \textit{\ULLAR{}}.}
    \hspace*{\fill}%
\end{figure}

\vskip 1.9in

\section{Inicio de \ULLAR{}} \label{chap:StartApplication} 

Para comenzar a desarrollar aplicación, primero, se necesita crear un proyecto nuevo en Android Studio. Este proyecto se nombra con el nombre de ``ULL\_Navigation'' y se siguen los pasos del IDE para acabar de crear el proyecto. Este proyecto contendrá el código de la aplicación ``\ULLAR{}''.  

A continuación, se explicarán en detalle el funcionamiento e implementación de las primeras ventanas que aparecen cuando se inicia la aplicación. 

\subsection{Ventana inicial}

La primera ventana que aparece en la aplicación es la \textit{Splash Screen}. El objetivo de esta ventana es dar una mejor apariencia a la aplicación e informar al usuario que la aplicación se está iniciando y cargando. 

En esta ventana se encuentra el logotipo de \ULLAR{} en el centro de la pantalla. Este logo se ha diseñado por medio del editor de imágenes online Pixlr \cite{URL::pixlr}. Gracias a este editor se ha podido crear un logotipo simple combinando el icono de la marca de la ULL y el nombre de la aplicación.
    

En un principio la velocidad de carga y transición a la siguiente ventana de la aplicación se hacía de forma inmediata, debido a que los recursos necesarios para el inicio de la aplicación son escasos y no tardan en cargarse. Por lo tanto, para poder visualizarla correctamente se utilizó un temporizador de tres segundos, para que posteriormente, se lance la siguiente ventana, la cual corresponde a la ventana de \textit{Inicio de sesión}.

Para la implementación de esta ventana \textit{Splash Screen} se ha de configurar primero el fichero \texttt{AndroidManifest.xml}. Este fichero proporciona información esencial sobre la aplicación al sistema Android, información que el sistema debe tener para poder ejecutar el código de la aplicación. Aquí se le indica al sistema Android la ventana o ``activity'' \cite{URL::activity} que inicia la aplicación (véase Listado \ref{lst:manifestInicio}). Además, a esta ventana se le indica el tema del activity que contendrá el logotipo de \ULLAR{} en el centro de la pantalla.

\begin{lstlisting}[language=XML,caption={Fichero \texttt{AndroidManifest.xml}, activity que inicia la aplicación.}, label={lst:manifestInicio}]
    ...
    <activity
        android:name=".Activities.SplashActivity"
        android:theme="@style/SplashScreen">
        <intent-filter> 
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
    </activity>
    ...
\end{lstlisting}

Al mismo tiempo en el archivo \texttt{styles.xml} (véase Listado \ref{lst:styleSplash}), se le indica que el archivo \texttt{splash\_ull.xml} (véase Listado \ref{lst:splashull}) se encargará de colocar el color del fondo y el logotipo de la aplicación en el fondo de la pantalla. 

\begin{lstlisting}[language=XML,caption={Fichero \texttt{styles.xml}, estilo de la \textit{Splash Screen}.}, label={lst:styleSplash}]
    ...
    <style name="SplashScreen" parent="Theme.AppCompat.NoActionBar">
      <item name="android:windowBackground">@drawable/splash_ull</item>
    </style>
    ...
\end{lstlisting}

\begin{lstlisting}[language=XML,caption={Fichero  \texttt{splash\_ull.xml}, configuración del color de fondo y el logotipo de la aplicación. }, label={lst:splashull}]
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@color/colorULL"/>
    <item>
        <bitmap
            android:src="@drawable/splash_icon"
            android:gravity="center"/>
    </item>
</layer-list>
\end{lstlisting}

\subsection{Ventana de \textit{Inicio de Sesión} }

Esta es la ventana que permitirá al usuario autentificarse con su correo institucional de la ULL. Para ello, dado que las cuentas de la ULL son cuentas de Google, se ha utilizado la API de Google para poder realizar la autenticación de forma sencilla y segura.

\subsubsection{ Requisitos }  

Para poder integrar la API de Google se necesita integrar los ``Servicios de Google'' en la aplicación. Para ello se ha de entrar en la consola de Firebase \cite{URL::Firebase} y crear un proyecto con el nombre de \ULLAR{}. Una vez dentro del proyecto, se seleccionará que se quiere integrar Firebase a una aplicación Android. A continuación, se pedirá el nombre del paquete de la aplicación y la clave ``SHA1". Para obtener esta clave, se ha de ejecutar en la consola de Android Studio el siguiente comando: 
 
\begin{lstlisting}[ label={lst:SHA1}]
    $ keytool -list -v -alias androiddebugkey -keystore ~/.android/debug.keystore
\end{lstlisting} 

Con el nombre del paquete y la clave SHA1, se descargará un fichero con la configuración de los Servicios de Google llamado \texttt{google-services.json}. Este fichero se ha de colocar en la carpeta \textit{app/} del proyecto.
 
Por último para poder utilizar los Servicios de Google en \ULLAR{}, se tiene que indicar al fichero \texttt{build.gradle} del proyecto en las dependencias (véase Listado \ref{lst:googleSd}) y al fichero \texttt{build.gradle} de la aplicación (véase Listado \ref{lst:googlepluggin}) que se quiere utilizar  los Servicios de Google.

\begin{lstlisting}[caption={Fichero \texttt{build.gradle} del proyecto, dependencias para utilizar los Servicios de Google.}, label={lst:googleSd}]
...
buildscript{
    dependencies {
        // Dependencias de los Servicios de Google
        classpath 'com.google.gms:google-services:4.0.0'
    }    
} 
...
\end{lstlisting}
 
\begin{lstlisting}[caption={Fichero \texttt{build.gradle} de la aplicación, dependencias y plugin para utilizar los Servicios de Google.}, label={lst:googlepluggin}]
...
dependencies {
    // Dependencia necesaria para poder autentificarse con una cuenta de Google
    implementation 'com.google.android.gms:play-services-auth:15.0.1'
}
// Plugin de los Servicios de Google
apply plugin: 'com.google.gms.google-services'
\end{lstlisting}

Con estos requisitos ya se puede comenzar a implementar la ventana que realiza la autentificación con una cuenta de Google. 

\subsubsection{ Implementación }


Se empieza creando un nuevo activity y se nombra \textit{LoginActivityULL}. Esto  generará un fichero \texttt{LoginActivityULL.java} que tendrá asociado fichero \texttt{login\_ull\_activity.xml} con un layout \cite{URL::layout}. Este layout será la vista del activity, con el logotipo de la aplicación y un botón para realizar el inicio de sesión con una cuenta de Google. La clase LoginActivityULL contiene los métodos y atributos que se encargarán de conectarse con los Servicios de Google para realizar una autentificación con una cuenta de correo de la ULL.


En el Listado \ref{code:loginUll.java} se muestran todos los métodos y conexiones de la API de Google para poder autentificarse. Cuando se presione el botón ``Autentifícate con una cuenta de la Universidad'' se abrirá un cuadro de diálogo de la API de Google que permitirá al usuario seleccionar la cuenta con la que desee entrar en la aplicación. 

\bigskip
\lstinputlisting[language=java, caption={Fichero \texttt{LoginActivityULL.java}, código que se encarga de realizar el inicio de sesión del usuario con su correo electrónico.}, label={code:loginUll.java},]{listings/LoginActivityULL.java} %% LISTING

En caso de que la cuenta no pertenezca a la ULL, es decir, una cuenta que no tenga el formato del dominio de las cuentas de correo de la ULL terminadas en ``@ull.edu.es'', se cerrará la sesión de esta cuenta y se mostrará un mensaje con el tipo de cuenta necesaria para utilizar  \ULLAR{}.

\bigskip
\bigskip
\bigskip
\bigskip
 
 
\section{Modo de Realidad Aumentada}

La técnica de realidad aumentada que se ha implementado en la aplicación es la de realidad aumentada basada en geolocalización. Es decir, a partir de la ubicación y la orientación de un dispositivo, se combina la información correspondiente a esos datos y la imagen que se obtiene de la cámara del dispositivo, para mostrar el resultado por la pantalla. Con estos datos de orientación y ubicación del dispositivo, junto con las ubicaciones de las instalaciones de la ULL, se podrán hacer los cálculos para identificar ante qué instalación se encuentra el usuario apuntando con la cámara del dispositivo móvil.

El fichero \texttt{ARNavigation.java} contiene el activity encargado de: la recogida de los datos de los sensores, conexión con el servidor de la aplicación, manejo de los objetos requeridos para la identificación de las instalaciones y de la visualización de la técnica de realidad aumentada implementada.

\subsection{Acceso a los sensores}

Para ubicar y orientar el dispositivo móvil en el mundo físico, se necesita obtener acceso a diferentes sensores de este: GPS, acelerómetro y magnetómetro. 

Para obtener acceso al GPS, se han de solicitar los permisos necesarios lo cual se refleja en el archivo \texttt{AndroidManifest.xml} (véase Listado \ref{lst:permisionL}) y a su vez requerir del usuario el permiso para acceder al GPS del dispositivo móvil con \ULLAR{}  (véase Listado \ref{lst:gpsP}).

\begin{lstlisting}[caption={Fichero \texttt{AndroidManifest.xml} del proyecto, permisos para acceder a la ubicación del dispositivo.}, label={lst:permisionL}]
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-feature android:name="android.permission.LOCATION_HARDWARE" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
\end{lstlisting}

\begin{lstlisting}[caption={Código para que el usuario conceda permiso para acceder a la ubicación del dispositivo.}, label={lst:gpsP}]
    // Si el usuario no ha concedido los permisos para utilizar el GPS en la aplicacion
    if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)
        != PackageManager.PERMISSION_GRANTED) { 
        // Se solicita el permiso para acceder a los datos de GPS de dispositivo 
        requestPermissions(new String[]{Manifest.permission.ACCESS_FINE_LOCATION},                  MY_PERMISSIONS_REQUEST_LOCATION);  
    }
\end{lstlisting}

Con los permisos concedidos, bastará con el código mostrado en el Listado \ref{lst:activarL} para empezar a requerir los datos del GPS.

\bigskip
\bigskip

\begin{lstlisting}[caption={Código para activar el GPS del dispositivo.}, label={lst:activarL}]
    locationManager = (LocationManager) getContext().getSystemService(Context.LOCATION_SERVICE);
    locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3000, 5, this);
    locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 3000, 5, this);
\end{lstlisting}

Para acceder a la última coordenada registrada por el GPS y así poder ubicar al usuario en el mundo físico, se utilizará la siguiente línea código:

\begin{lstlisting}[label={lst:ubicacionL}]
    currentLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
\end{lstlisting}

Ahora que se tiene acceso al GPS del dispositivo, se necesita conocer su orientación. Para ello se hará uso de la matriz de rotación que Android calcula a partir del acelerómetro y el magnetómetro. Con esta matriz se obtendrá el valor de la brújula magnética del dispositivo, es decir, su orientación con respecto al norte magnético. Este valor será el que se utilizará para identificar hacia donde está orientado el dispositivo en el mundo.

\begin{lstlisting}[caption={Código para acceder a la última ubicación registrada del GPS.}, label={lst:ubicacionL}]
    // Se accede a los sensores del dispositivo
    mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE); 
    // Se accede al calculo de la matriz de rotacion que proporciona el valor de la brujula magnetica del dispositivo
    Sensor compass = mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION);
    // Se escuchan a los cambios del sensor
    mSensorManager.registerListener(this, compass, SensorManager.SENSOR_DELAY_NORMAL);    
\end{lstlisting}
 
Un dispositivo Android dispone de 3 ejes: x, y, z. Estos ejes se disponen como se muestra en la Figura \ref{fig:xyz}. La variable ``compass'' está formada por una lista de tres valores. El primero es denominado acimut y se refiere al ángulo de la orientación sobre la superficie de una esfera. Este valor representa el ángulo entre el eje ``y'' del dispositivo y el norte magnético en grados. Cuando se apunta con el dispositivo hacia el norte el valor del ángulo es 0, al sur es 180º, al este es 90º y al oeste 270º. Para poder trabajar con estos valores se convertirán a radianes.  El rango de valores es desde $0$ a $2\pi$.

Para reconocer las instalaciones que se encuentran en frente del dispositivo móvil, se escucharán los cambios de los valores brújula o ``compass'' del dispositivo para actualizar la nueva orientación y realizar los cálculos que permiten identificar las instalaciones (véase Listado \ref{lst:orientacionL}). El objeto ``navULL'' de la clase ``Navigation'' será el encargado realizar estos cálculos, los cuales se explicarán a continuación.


\begin{figure}[h]
    \centering
    \includegraphics[width=0.38\linewidth]{xyz}
    \caption{Disposición de los ejes de un dispositivo Android.}
    \label{fig:xyz}
\end{figure}    

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Código que se ejecuta cada vez que se registra un cambio en el sensor que calcula la orientación.}, label={lst:orientacionL}]
    // Se escuchan los cambios en el sensor y se hacen los calculos
    public void onSensorChanged(SensorEvent event) {
        // Valor del sensor en grados
        double radians = event.values[0]; 
        // Se convierte a radianes
        radians = Math.toRadians(radians);
        // Se obtiene la ultima posicion registrada del GPS
        LatLng lastPosition = getCurrentPos();
        if (auxpos != null) { // Si la posicion no es nula
            // Se le pregunta al objeto de la clase ``Navigation'' las instalaciones 
            // que se encuentran en esa direccion
            allResultsSites = navULL.whatCanSee(lastPosition, radians);
        }
        // Si se obtiene al menos un resultado
        if (allResultsSites != null) {
            // Se obtiene la instalacion mas cercana, el indice 0 corresponde a la mas cercana
            nearSiteResult = allResultsSites.get(0);
            ... // Se muestra su informacion por pantalla para que usuario conozca la instalacion  
                // a la que se encuentra apuntando y un boton que lanza una con una ficha de 
                // informacion sobre esta
            if(allResultsSites.size() > 2) {
                ... // Si se obtiene mas de una instalacion se muestra al usuario el boton
                    // que indica el numero de instalaciones que se encuentran en la misma
                    // direccion y lanza una ventana con una lista de estas
            }
        } else { ... }
    } 
\end{lstlisting}
\end{minipage}

\subsection{Modelos encargados de la navegación}

A continuación, se explicarán las clases que intervienen en el proceso de reconocimiento de las instalaciones de la ULL que se encuentran frente al dispositivo móvil.

\subsubsection{ULLSite.java}

Cada instalación de la ULL se obtiene de una base de datos en formato JSON. Una instalación se representa con un objeto de la clase ``ULLSite''. Esta contiene toda su información y los atributos y funciones necesarias para poder trabajar con ella (véase Listado \ref{lst:ULLSite}). El objeto en formato JSON a partir de cual se creará el objeto de cada instalación se puede ver en el Listado \ref{lst:instalacion}.

\lstinputlisting[language=java, caption={Fichero \texttt{ULLSite.java}, clase que contiene los atributos de una instalación de la ULL.}, label={lst:ULLSite},]{listings/models/ULLSite.java}

\lstinputlisting[ caption={Ejemplo de una instalación de la ULL en la base de datos.}, label={lst:instalacion},]{listings/instalacion.json}


    % \begin{figure}[h] 
    %     \centering
    %     \includegraphics[width=150mm,scale=1]{ull-site}
    %     \caption{Ejemplo de una instalación de la ULL en la base de datos.}
    %     \label{fig:ull-site}
    % \end{figure}

En la clase ``ULLSite'' se encuentran los tres atributos principales para la identificación de las instalaciones: ``disToSite'', ``dirToSite'' y ``coneValue''. Estos atributos son calculados en tiempo de ejecución.

El atributo ``disToSite'' representa la distancia, en metros, a la que se encuentra la instalación con respecto a la ubicación del dispositivo. El atributo ``dirToSite'' representa el valor de la brújula del dispositivo, en radianes, en la dirección en la que se encuentra la instalación, es decir, si la ubicación se encuentra hacía el norte con respecto al dispositivo el valor será 0 y si se encuentra hacía el este será $pi/2$.
El atributo ``coneValue'' representa un cono de visión imaginario cuyo centro es la dirección en la que se encuentra la instalación. 
Este cono forma un rango de visión alrededor de la dirección de la instalación a partir de la cual si el dispositivo se encuentra apuntando dentro de este rango se considerará que éste está ``viendo'' la instalación. 
El valor del atributo ``coneValue'' variará en función de la distancia a la que se encuentre el dispositivo de la instalación.  
Estos atributos junto con el objeto ``point'' de la clase ``Vector2D'', que contiene la ubicación en un plano de coordenadas cartesianas, permitirán realizar los cálculos para identificar si el dispositivo se encuentra apuntando a una instalación o no.


\begin{figure}[h] 
    \centering
    \includegraphics[width=160mm,scale=1]{calculateDirSite}
    \caption{Explicación de los atributos ``coneValue'' y ``dirToSite''.}
    \label{fig:dirSite}
\end{figure}
  
\subsubsection{Navigation.java}

La clase ``Navigation'' es la clase principal encargada de  ejecutar todos métodos y realizar  los cálculos que permiten identificar las instalaciones. A partir de los datos obtenidos de los sensores y de las ubicaciones de las instalaciones permite identificar la instalación más cercana que se encuentra en la dirección del dispositivo y también el resto de las instalaciones en esta misma dirección. En el Listado \ref{lst:NavigationResumen} se muestran los atributos y métodos de la clase.

\bigskip

\lstinputlisting[language=java, caption={Fichero \texttt{Navigation.java}, clase ``Navigation'' que contiene los atributos y métodos que nos permiten identificar las instalaciones de ULL.}, label={lst:NavigationResumen},]{listings/NavigationResumen.java}

A continuación se explicará de forma detallada la implementación de los métodos principales de esta clase.

En Listado \ref{lst:calculateCone} se encuentra el método que calcula el valor del atributo ``coneValue'' para una instalación. 
Este valor se calcula de modo que cuanto más cerca se encuentre el dispositivo de una instalación, mayor sea el rango con el que poder decidir si se encuentra delante de ella o no y, por el contrario, que este valor sea menor cuando se encuentre lejos de la instalación.
\bigskip

\bigskip

\bigskip
\begin{lstlisting}[caption={Código para calcular el \textit{coneValue} de identificación de cada instalación.}, label={lst:calculateCone}]
    public double calculateCone(double dist) {
        // Si es una instalacion "cercana" del dispositivo
        if (dist <= NEAR_VALUE) {
            // Se calcula el valor del coneValue restandole al valor maximo las distancia a la instalacion por la constante SCALE_CONE_NEAR que permite que esta se escale gradualmente.
            return MAX_CONE_GRADS_NEAR - dist * SCALE_CONE_NEAR;
        }else { // Si es "lejana"
            // Se calcula el valor del coneValue restandole al valor maximo las distancia a la instalacion por la constante SCALE_CONE_FAR que permite que esta se escale gradualmente en instalaciones lejanas.
            double auxCone = MAX_CONE_GRADS_FAR - dist * SCALE_CONE_FAR;
            if (auxCone < MIN_CONE_GRADS) {
                return MIN_CONE_GRADS;
            } else {
                return auxCone;
            }
        }
    }
\end{lstlisting}


El cálculo del ángulo formado por dos puntos geográficos se realiza con el método ``Vector2D.getAngleRad(Vector2D v2)'', como se puede ver en el Listado \ref{lst:angle}. Este método calcula el ángulo que se obtiene al transformar el plano de coordenadas rectangulares (distancia en eje ``x'' y distancia en el eje ``y'') generado por la diferencia entre el punto con la ubicación geográfica del dispositivo ``v2'' y el punto con la ubicación geográfica de la instalación contenida en ``getX()'' y ``getY()'', a coordenadas polares. En las coordenadas polares un punto en el plano se determina por una distancia y un ángulo. Este ángulo que se obtiene será la dirección en la que se encuentra la instalación.


\begin{lstlisting}[caption={Método que calcula el ángulo formado por dos puntos.}, label={lst:angle}]
    // Metodo que calcula el angulo que se obtiene al transformar el rectangulo formado por este punto y el punto v2 a coordenadas polares
    public double getAngleRad(Vector2D v2) {
        double dx = v2.getX() - getX(); // Se calculan las distancias en el eje x e y
        double dy = v2.getY() - getY(); // se obtiene el rectangulo formado por estos dos puntos
        double radian = Math.atan2(dy, dx); // Se realiza la arcotangente para calcular el angulo del rectangulo formado
        return radian; // Se devuelve el resultado
    }
\end{lstlisting}

A este ángulo, hay que aplicarle unas transformaciones para que se ajuste a la orientación del norte magnético como el inicio de la rotación (norte magnético = 0º), para ello, el método ``Navigation.recalculeAng(double angleRad)'' se encarga de la correcta reorientación (véase Listado \ref{lst:reca}). 

\begin{lstlisting}[caption={Método que recalcula en ángulo para orientarlo en función del norte magnético.}, label={lst:reca}]
    private double recalculeAng(double angleRad) {
        double aux = rotateRad(angleRad); // Rota -pi/2
        aux = invertAng(aux);             // Se invierte el angulo 
        return aux;                       // Se devuelve el resultado
}   
\end{lstlisting}

El método ``whatCanSee'' (véase el Listado \ref{lst:whatCanSee}) es el método principal que se encargará, a partir de los datos de ubicación y dirección del dispositivo, de identificar qué instalaciones se encuentran en frente del dispositivo y cuál es la más cercana. 
Para ello, en un primer paso, se calculan las distancias de las  instalaciones y las que se encuentran a una distancia mayor que ``maxDist'' y menor que ``minDist'' serán descartadas, para poder reducir el número de instalaciones a identificar. 
A continuación, para cada instalación anterior se calcula su dirección, posición y el valor del cono, con respecto a la ubicación del dispositivo. Si la instalación se encuentra orientada dentro del cono que se forma en la dirección de la instalación, esta instalación se considerará como un posible resultado y se añadirá a la variable con una lista de estos resultados, ``result''. 
De los posibles resultados, la instalación más cercana al dispositivo será la instalación ante la que teóricamente se encuentra el dispositivo y guardará ésta en el principio de esta lista.
 
\begin{lstlisting}[caption={Método principal que realiza el cálculo que permite reconocer las instalaciones que se hallan frente al dispositivo móvil.}, label={lst:whatCanSee}]
    // Metodo principal que se encarga identificar las instalaciones en frente del dispositivo
    // Recibe la posicion y orientacion actual del dispositivo
    // Devuelve la lista de instalaciones en esa direccion indicando cual es la mas cercana 
    public ArrayList<ULLSite> whatCanSee(LatLng currentPosAux, double actualDir) {
        currentPos.set(actualPos.longitude, actualPos.latitude); // Posicion actual del dispositivo
        currentDir = actualDir;  // Orientacion del dispositivo
        int id = -1;  // Indice de la instalacion mas cercana en frente del dispositivo
        double nearSiteDist = maxDist; // Distancia maxima valida para identificar un instalacion
        // Array a devolver con las instalaciones encontradas
        ArrayList<ULLSite> result = new ArrayList<>(); 
        // Se calculan todas las instalaciones que se encuentran entre maxDist y minDist
        for (int i = 0; i < allSites.size(); i++) {
            double distToSite = getDistanceBetween(currentPos, allSites.get(i).getPoint());
            if ((distToSite < maxDist) && (distToSite > minDist)) {
                destSites.add(allSites.get(i));
            }
        }
        // Para cada una las instalaciones dentro del rango anterior 
        for (int i = 0; i < destSites.size(); i++) {  
            // Se calcula la direccion, distancia y valor del cono de cada instalacion a partir 
            // de la actual ubicacion del dispositivo
            double dirToSite = recalculeAng(currentPos.getAngleRad(destSites.get(i).getPoint()));
            double distToSite = getDistanceBetween(currentPos, destSites.get(i).getPoint());
            double coneValue = calculateCone(distToSite);
            // Se comprueba si el dispositivo esta orientado hacia dentro del cono que se forma en  
            // la direccion de la instalacion
            if (isInCone(dirToSite, coneValue)) { 
                // Se guarda los valores calculados anteriormente en el objeto ULLSite del array
                destSites.get(i).setConeValue(coneValue); 
                destSites.get(i).setDirToSite(dirToSite); 
                destSites.get(i).setDistToSite(distToSite); 
                result.add(destSites.get(i)); // Se guarda esta instalacion como resultado
                if (nearSiteDist > distToSite) { // Se comprueba si es la instalacion mas cercana
                    nearSiteDist = distToSite; // Si lo es, se actualiza la distancia mas cercana
                    id = i;                    // Se guarda el indice de la instalacion mas cercana
                }
            }
        }
        if (id != -1) {                        // Si se ha encontrado alguna instalacion
            result.add(0, destSites.get(id));  // La instalacion mas cercana la se guarda la primera
            return result;                     // Se devuelve las instalaciones                   
        } else
            return null;                        // Si no se encuentra ninguna instalacion
    }
\end{lstlisting}


\subsection{Obtención de la información}

Como se ha comentado anteriormente, toda la información perteneciente a las instalaciones de la ULL estará en una base de datos. 
Además, para comunicarse con ésta, se dispone de un servidor que atienda a las peticiones de la aplicación, se conecte con esta base de datos y  envie la información. 
Más adelante, en la Sección \ref{chap:BackEnd}, se explicará detalladamente el funcionamiento de esta base de datos y servidor. Por ahora, se explicará cómo se realiza la conexión con el servidor y el tipo de respuesta que se obtiene.

Para poder realizar una petición al servidor se utilizará la clase ``GetData''. 
Esta clase formaliza una petición con la URL que se le pase como parámetro al método ``doInBackground'' y devuelve una cadena de caracteres con la respuesta del servidor. En el Listado \ref{lst:getData} se puede ver cómo funciona este método. 

\lstinputlisting[language=java, caption={Fichero \texttt{GetData.java}, código encargado de la conexión con el servidor y manejo de la respuesta.}, label={lst:getData},]{listings/models/GetData.java} 

En el Listado \ref{lst:getSitesFromDB} se encuentra el método ejecutado en la clase ``ARNavigation'' para realizar la conexión con el servidor para obtener la respuesta de la base de datos con todas las instalaciones de ULL. Posteriormente, se creará una instancia de la clase ``Navigation'' con todas las instalaciones de la base de datos en formato JSON. Este objeto se denominará con el nombre de ``navULL'' y será el objeto encargado de identificar las instalaciones y trabajar con ellas.

\begin{lstlisting}[caption={Método que conecta con el servidor y recibe la respuesta con todas las instalaciones de la base de datos.},  label={lst:getSitesFromDB}]
    private void getSitesFromDB() {
        try{
            GetData getSites = new GetData();
            String sites = getSites.execute("https:// server-ull-ar.herokuapp.com/api/ull-sites").get();
            JSONArray array = new JSONArray(sites);
            // Se crea una instancia de la clase "Navigation" con todas las instalaciones
            // Este es el objeto encargado de encontrar las instalaciones
            navULL = new Navigation(array); 
        } catch (JSONException e) {...}
}
\end{lstlisting}

Los últimos datos que se necesitan para trabajar con en el objeto ``navULL'', son los valores de ``maxRadius'' y ``minRadius'', los cuales el usuario puede editar en la ventana de \textit{Configuración} y que se puede acceder desde cualquier activity gracias a las ``Shared Preferences". Las Shared Preferences son un conjunto de datos accesible desde cualquier activity de la aplicación y que se utiliza para guardar los ajustes del usuario. En el método ``getRadius()'' del Listado \ref{lst:shared} se puede ver como se accede a estos datos.

\begin{lstlisting}[language=java, caption={Fichero \texttt{ARNavigation.java}, código que se encarga de obtener los valores de ``maxDist'' y ``minDist'' del objeto ``navULL''},  label={lst:shared}]
    private void getRadius() {
        try {
            // Se obtiene los valores configurables "maxRadius" y "minRadius" en la ventana de 
            // "Configuracion"
            settingsPref = PreferenceManager.getDefaultSharedPreferences(getContext());
            String auxMaxRadius = settingsPref.getString("maxRadius", "null");
            String auxMinRadius = settingsPref.getString("minRadius", "null");
            navULL.setMaxDist(Integer.parseInt(auxMaxRadius)); // Se guarda el valor "maxRadius"
            navULL.setMinDist(Integer.parseInt(auxMinRadius)); // Se guarda el valor "minRadius"
        }catch (Exception e) { ... }
    }
\end{lstlisting}

\subsection{Visualización}

El activity ``ARNavigation'' será el encargado de mostrar la técnica de realidad aumentada por geolocalización en la pantalla de dispositivo móvil. Este activity hereda de la clase ``ARActivity'' perteneciente al  SDK de Kudan para Android Studio. Este SDK permite el reconocimiento de objetos e imágenes a través de la cámara del dispositivo y queda como recurso para una futura ampliación de la funcionalidad de la aplicación. El uso principal de este SDK en \ULLAR{}, es el acceso que otorga a cámara del dispositivo como vista principal del activity. Es decir, permite visualizar en la ventana lo que se está observando con la cámara.

Para poder hacer uso del SDK de Kudan se tiene que descargar el SDK y configurar la ``ARAPIkey'' específica para el proyecto. Ambos se pueden encontrar en la página oficial de Kudan \cite{URL::kudan}. 

% El archivo que contiene el SDK descargado, llamado \texttt{KudaAR.aar}, se tiene que pegar en la carpeta \textit{/app/libs/} del proyecto. A continuación se tiene de añadir la siguiente línea de código a las dependencias del fichero \texttt{build.gradle} de la aplicación:

% \begin{lstlisting}
%     implementation(name: 'KudanAR', ext: 'aar')
% \end{lstlisting}

% La configuración de la clave de la API de Kudan se realizará con el código del Listado \ref{lst:arapi}.

% \begin{lstlisting}[caption={Fichero \texttt{ARNavigation.java}, código para configurar la API de Kudan.},  label={lst:arapi}]
%     protected void onCreate(Bundle savedInstanceState) { // Cuando se inicie el activity
%         ...
%         ARAPIKey key = ARAPIKey.getInstance(); 
%         key.setAPIKey("ARAPIKey..."); // ARAPIKey, clave generada por Kudan para el proyecto
%     }
% \end{lstlisting}
 
El fichero \texttt{aractivity.xml} (véase Listado \ref{lst:aractivity.xml}) contiene el layout con la información a mostrar al usuario cuando esté delante de una instalación. Este layout muestra al usuario en la parte superior de la ventana, el nombre de la instalación ante la que se encuentra y un botón que le permite acceder a una ventana con la ficha de información de la instalación. Además incorpora un botón en la parte inferior que le indica el número de instalaciones adicionales que se encuentran en la misma dirección. Al pulsar este botón se despliega una ventana con una lista de estas instalaciones.

\lstinputlisting[stringstyle=\color{purple},language=XML, caption={Fichero \texttt{aractivity.xml}, layout del activity ``ARNavigation''.}, label={lst:aractivity.xml},]{listings/aractivity.xml}

Los elementos del layout se mostrarán u ocultarán en función de si el usuario se  encuentra en frente de una instalación o no. Como se puede ver en el Listado \ref{lst:orientacionL}, se muestra cómo y cuándo se alterna la información del layout.

Por último, se ha de configurar el funcionamiento de los botones ``moreInfoButton'' y ``moreSitesButton'' (véase Listado \ref{lst:infobutton}), que mostrarán, respectivamente, una ventana con la ficha de información de la instalación que se está viendo actualmente y una ventana con una lista que contiene el resto de las instalaciones que se encuentran en la misma dirección. 

\begin{lstlisting}[caption={Fichero \texttt{ARNavigation.java}, código para manejar los eventos de los botones.},  label={lst:infobutton}]
    public void onClick(View v) {
        if(v.getId() == moreSitesButton.getId()) { // Si coincide
            ... // Se inicializa el activity que muestra una lista de las instalaciones adicionales
            ArrayList aux = new ArrayList(moreResultsSites.subList(1, moreResultsSites.size()-1));
            SitesArray sitesArray = new SitesArray(aux);
            // Se le pasa como "extra" una la lista con las instalaciones a mostrar
            intent.putExtra("sitesToShow", sitesArray);
            startActivity(intent); // Se inicia el activity
        }
        if(v.getId() == moreInfoButton.getId()) { // Si coincide
            ... // Se inicializa el activity que muestra la descripcion de la instalacion
            ULLSiteSerializable actualULLSite = new ULLSiteSerializable(nearSiteResult);
            // Se le pasa como "extra" el objeto que contiene la informacion de la instalacion
            intent.putExtra("actualULLSite", actualULLSite);
            startActivity(intent); // Se inicia el activity
        }
    }
\end{lstlisting}

\section{Fragmentos}

Los fragmentos \cite{URL::fragment} actúan como una sección modular de un activity que tiene su ciclo de vida propio, es decir, recibe sus propios eventos de entrada y que se pueden agregar o quitar mientras el activity se esté ejecutando. Se han utilizado estos fragmentos para mostrar el contenido de ciertas ventanas de la aplicación. La principal ventaja que  aportan los fragmentos es la facilidad que otorgan para intercambiar estos fragmentos dentro de un mismo activity y la mejora de rendimiento que se obtiene con respecto a creación de un activity para cada ventana que se quiera en la aplicación.

\subsection{MapsFragment}
       
Este fragmento contiene el mapa generado por la API de Google Maps. Para poder utilizar esta API, se tiene que acceder a la consola de desarrolladores de Google \cite{URL::consoleGoogle}. En ella se tiene que crear un proyecto con el nombre de \ULLAR{}, para después habilitar la API de ``Maps SDK for Android". Una vez habilitada se otorgará una clave que se encuentra en el fichero \texttt{app/res/values/google\_maps\_api.xml} (véase Listado \ref{lst:apiMaps}).

\begin{lstlisting}[stringstyle=\color{purple},language=XML,caption={Fichero \texttt{google\_maps\_api.xml}.},  label={lst:apiMaps}]
<resources>
    <string name="google_maps_key" templateMergeStrategy="preserve" translatable="false">API_Maps</string>
</resources>
\end{lstlisting}
 
A su vez, se debe añadir la siguiente línea a las dependencias de fichero \texttt{build.gradle} de la aplicación:
 
\begin{lstlisting}
    implementation 'com.google.android.gms:play-services-maps:15.0.1'
\end{lstlisting}

Con esto ya se puede utilizar la API de Google Maps en la aplicación. Ahora toca implementar el fragmento que contendrá la vista de Google Maps. 

Se crea un fragmento en Android Studio con el nombre de \textit{MapsFragment}. Se generará un fichero llamado \texttt{MapsFragment.java} y un layout asociado, \texttt{fragment\_maps.xml}.

La clase ``MapsFragment'' (véase Listado \ref{lst:mapsF}) se encargará de: obtener la ubicación, dibujar en el mapa los marcadores de las instalaciones de ULL, obtener la ubicación del dispositivo y, si se activa en los ajustes, de obtener las dos circunferencias, cuyo centro será la ubicación del dispositivo y que representarán un rango de búsqueda de las instalaciones. Este rango funcionará a modo de que solo aparezcan las instalaciones que se encuentran en el espacio entre las dos circunferencias. En esta clase se harán uso de los métodos que ya se mostraron para obtener la ubicación GPS, las instalaciones de la base de datos y los datos necesarios guardados en las Shared Preferences.   

\bigskip

\lstinputlisting[caption={Fichero \texttt{MapsFragment.java}, métodos principales.}, label={lst:mapsF},]{listings/MapsFragment.java}

El fichero \texttt{fragment\_maps.xml} contiene la vista del mapa de Google Maps en el cual se dibujarán los marcadores y los círculos que ya se han comentado. Además incorpora un botón con el nombre de ``AR Mode'' que lanzará la ventana de \textit{Navegación en modo AR}.

% \lstinputlisting[stringstyle=\color{purple},language=XML,caption={Fichero \texttt{fragment\_maps.xml}, vista del mapa de la API de Google Maps.}, label={lst:mapsL},]{listings/fragment_maps.xml}
    

\subsection{HomeFragment}

El fragmento ``HomeFragment'' es la primera vista que se encuentra cuando se inicia sesión con éxito en la aplicación. Para el diseño de este fragmento se decidió por utilizar el modelo de ``RecyclerView'' \cite{URL::recycler}. Este modelo permite la visualización de listas de elementos o ítems de una forma más flexible, permitiendo configurar la vista de cada ítem mediante el uso de adaptadores. Un adaptador permite crear las vistas de cada ítem de una lista a partir del contenido de los atributos de cada uno de ellos. Además, cada adaptador gestiona los eventos de cuando un ítem es seleccionado.

El contenido de cada ítem vendrá dado por la clase ``ItemHome''. Los atributos de esta clase serán: una imagen, un nombre, una variable que indica si es o no un enlace web del navegador y la URL del enlace.

% \begin{lstlisting}[caption={Fichero \texttt{ItemHome.java}, clase de que contendrá  el contenido de cada ítem de la ventana de \textit{Inicio}.},  label={lst:itemhom}]
% public class ItemHome {
%     private String name;        // Nombre
%     private String image;       // Ruta de la imagen
%     private boolean isWebLink;  // Si es true es un enlace web externo
%     private String link;        // Ruta del enlace
%     // Constructor con los parametros
%     public ItemHome(String name, String image, boolean isWebLink, String link) {
%         ...
%     }
%     ... // Metodos Get() y Set() de los atributos
% }
% \end{lstlisting}

Con una lista de estos ítems, el adaptador configurará la vista de cada ítem y luego se incorporarán a la vista de RecyclerView. La clase encargada de este procedimiento se llamará ``ItemHomeAdapter'' y hereda del adaptador ``RecyclerView.Adapter'' (véase Fichero \ref{lst:adapterItem}). Los atributos de esta clase son: una lista de ítems, el layout con el diseño de cada ítem y un objeto ``OnItemClickListener'' que manejará los eventos de cada ítem. Dentro de esta clase, se tiene una clase ``ViewHolder'' que hereda de ``RecyclerView.ViewHolder'' y se encargará de enlazar el contenido de cada ítem con su layout. El layout con la vista de cada ítem se encuentra en el fichero \texttt{adapter\_item\_home.xml}. Este layout contendrá la imagen del ítem en la parte superior y el nombre inferior.
     
    
% \lstinputlisting[stringstyle=\color{purple},language=XML,caption={Fichero \texttt{adapter\_home\_item.xml}, vista del adaptador de cada ítem de la ventana de \textit{Inicio}.}, label={lst:itemView},]{listings/adapter_home_item.xml}

\bigskip

\begin{lstlisting}[caption={Fichero \texttt{ItemHomeAdapter.java}, clase que construye las vistas de los ítems.},  label={lst:adapterItem}]
public class ItemHomeAdapter extends RecyclerView.Adapter<ItemHomeAdapter.ViewHolder> {
    private List<ItemHome> items;
    private int layout;
    private OnItemClickListener itemClickListener;
    public ItemHomeAdapter(List<ItemHome> items, int layout, OnItemClickListener listener) {
        ... // Se asignan a los atributos con sus respectivos valores
    }
    // El parametro @ViewGroup parent contendra la vista de todos los items
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View v = LayoutInflater.from(parent.getContext()).inflate(layout, parent, false);
        ViewHolder vh = new ViewHolder(v);     // Objeto ViewHolder  
        return vh;                             // Se devuelve la vista    
    }
    // Se enlaza cada item con su objeto ViewHolder
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        holder.bind(items.get(position), itemClickListener);
    }
    // Clase que hereda de RecyclerView.ViewHolder que sera la vista de cada item
    public static class ViewHolder extends RecyclerView.ViewHolder { 
        public TextView itemName;     
        public ImageView itemImage;   
        ...
        public ViewHolder(View itemView) { // Constructor con el layout
            ... // Se enlaza la informacion de los objetos con su layout
            this.itemName = itemView.findViewById(R.id.textView_home_item);     
            this.itemImage = itemView.findViewById(R.id.imageView_home_item);
        }
        // Se asigna a cada vista el contenido de su item correspondiente 
        public void bind(final ItemHome itemHome, final OnItemClickListener listener) {
            this.itemName.setText(itemHome.getName()); // Se asigna el texto
            ... // Se asigna la ruta de la imagen
            itemView.setOnClickListener(new View.OnClickListener() { ... }); // Listener del item
    }
}
\end{lstlisting}

La clase ``HomeFragment''(véase Listado \ref{lst:homeF}) se encargará de crear una instancia de la clase ``ItemHome'' y el adaptador, ``ItemHomeAdapter'', para que se sitúen correctamente en la vista que contiene el RecyclerView (véase Listado \ref{lst:homeL}). 

\lstinputlisting[caption={Fichero \texttt{HomeFragment.java}, activity de la ventana de \textit{Inicio}.}, label={lst:homeF},]{listings/HomeFragment.java}

\lstinputlisting[stringstyle=\color{purple},language=XML,caption={Fichero \texttt{fragment\_home.xml}, vista principal de la ventana de \textit{Inicio}.}, label={lst:homeL},]{listings/fragment_home.xml}
  


\subsection{AboutFragment}

El fragmento ``AboutFragment'' se encarga de mostrar la ventana de \textit{Información} la aplicación con la información general de la aplicación como su autor, versión, correo de contacto y una descripción de la misma. Este consta simplemente de un fichero \texttt{Fragment.java} que muestra el layout que contiene esta información en texto plano.

% \lstinputlisting[stringstyle=\color{purple},language=XML,caption={Fichero \texttt{fragment\_about.xml}, vista de la ventana de \textit{Información}.}, label={lst:aboutL},]{listings/fragment_about.xml}

\section{Menú}

El menú de la aplicación constituye el elemento principal por el que el usuario navegará por la misma. Por ello se ha optado por incorporar un menú lateral deslizante llamado \textit{Navigation Drawer}. Este es un menú que ha sido implementado por Google, se encuentra en sus principales aplicaciones como ``Gmail'' y ``Google Play''. Un menú Navigation Drawer es un layout que incorpora dentro del mismo la vista de otras ventanas que se encuentren formato de fragmentos y facilita que el cambio entre los fragmentos sea fluido y rápido. Este menú (véase Figura \ref{fig:menuApp}) se desplegará pulsando en la esquina superior izquierda de la aplicación.
   
El fichero \texttt{navigation\_draw.xml} contiene la vista del Navigation Draw. Aquí se cuenta con un layout que muestra: la barra superior de la aplicación en la que irá el nombre de la aplicación ``\ULLAR{}'', un ``FrameLayout'' en el que irá el fragmento actual a mostrar y un ``NavigationView'' que será la vista del menú Navigation Drawer y que al inicio de la aplicación estará sin desplegar.

\lstinputlisting[stringstyle=\color{purple},language=XML, caption={Fichero \texttt{navigation\_draw.xml}, layout del Navigation Drawer.}, label={code:navigation_draw.xml},]{listings/navigation_draw.xml}

En cuanto al contenido del menú del Navigation Drawer, se encuentra una cabecera en la parte superior del menú con una imagen de la ULL y el nombre del usuario. Después de la cabecera se encuentran las opciones del menú que vienen dadas por el fichero \texttt{nav\_options.xml} (véase Listado \ref{lst:nav_options.xml}). Cada uno de los ítems del menú de opciones tiene: un identificador, un icono asociado y un nombre.

% \lstinputlisting[stringstyle=\color{purple},language=XML, caption={Fichero \texttt{header\_navigation\_drawer.xml}, cabecera del Navigation Drawer.}, label={code:header_navigation_drawer.xml},]{listings/header_navigation_drawer.xml}
   
\bigskip

\lstinputlisting[stringstyle=\color{purple},language=XML, caption={Fichero \texttt{nav\_options.xml}, opciones del menú Navigation Drawer.}, label={lst:nav_options.xml},]{listings/nav_options.xml}

Para la implementación del menú se ha utilizado una clase heredable llamada ``BaseActivity'', la cual incorpora la vista del Navigation Drawer, gestionará las opciones del menú, cambiará los fragmentos y permitirá moverse a los activities principales de \ULLAR{}. 

\lstinputlisting[language=java, caption={Fichero \texttt{BaseActivity.java}, código que se encarga de configurar la vista del Navigation Drawer.}, label={BaseActivity.java},]{listings/BaseActivity.java}

Con esta clase cualquier activity que quiera incorporar el menú Navigation Drawer  solo tiene que heredar de ésta mediante la palabra reservada en Java ``extends'' y el nombre de la clase ``BaseActivity''.

        
\section{Instalaciones de la ULL}

En la base de datos se encuentran con la gran mayoría de las instalaciones de la ULL. Se recuerda que todas estas instalaciones constan de su nombre, ubicación, una breve descripción de esta y una lista de enlaces a los servicios, titulaciones, departamentos, etc. Toda esta información puede ser consultada por el usuario, mediante la ventana de \textit{Todas las instalaciones} (véase Figura \ref{fig:allSitesApp}). Esta ventana permite al usuario buscar la facultad, edificio o centro, que se encuentre en la base de datos, para posteriormente permitirle acceder a la ficha de información de la instalación (véase Figura \ref{fig:siteInfoApp}). En esta ficha se encontrará el resto de la información con respecto a esa instalación.

En la ventana de \textit{Todas las instalaciones}  aparecerá una lista de ítems con todas las instalaciones con: su imagen a la izquierda y, su nombre y descripción a la derecha. Para la creación de los ítems de la lista se optó por el uso de adaptadores al igual que en el fragmento ``HomeFragment'', pero sin la necesidad de una vista RecyclerView. La clase encargada de representar las instalaciones es ``SiteAdapter'', la cual hereda de la clase ``BaseAdapter'' de Android y, además, implementa la interfaz ``Filterable'' que permite aplicar, de forma dinámica, un filtro de búsqueda sobre la lista de las instalaciones (véase Listado \ref{lst:SiteAdapter.java}). El contenido a representar en cada vista vendrá dado por una lista de objetos de la clase ``ULLSiteSerializable''. Esta clase es una copia de la clase ``ULLSite'' (véase Listado \ref{lst:ULLSite}), pero que implementa la interfaz ``Serializable'' para permitir el paso de objetos de esta clase entre distintos activities. 


\lstinputlisting[language=java, caption={Fichero \texttt{SiteAdapter.java}, adaptador que configura la lista de instalaciones con su imagen, nombre y descripción.}, label={lst:SiteAdapter.java},]{listings/adapters/SiteAdapter.java}


El activity ``SiteListActivity'' (véase Listado \ref{lst:SiteListActivity.java}) se encargará de crear una instancia del adaptador ``SiteAdapter'' con la lista de objetos de las instalaciones, las cuales recibe del activity anterior que lo ejecutó. Esté activity dispone de una barra de búsqueda la parte superior de la aplicación que permite al usuario buscar una instalación por su nombre. Esta indicará, al adaptador, el filtro de búsqueda que tiene aplicar a los nombres de las instalaciones cada vez que se escriba en ella o cuando el usuario le dé al botón de buscar, de esta manera solo aparecerán una lista de instalaciones que coinciden con los caracteres de la barra de búsqueda. Cuando una instalación de la lista sea seleccionada, se lanzará el activity ``SiteDescriptionActivity'' y se le pasará el objeto que contiene la instalación seleccionada.

\lstinputlisting[language=java, caption={Fichero \texttt{SiteListActivity.java}.}, label={lst:SiteListActivity.java},]{listings/SitesListActivity.java}
    

El activity ``SiteDescriptionActivity'' muestra toda la información de la instalación contenida en el objeto ``ULLSiteSerializable'' proveniente del activity que ejecutó o lanzo a este. Este activity dispone de una ventana con: la imagen de la instalación junto con un botón en la parte inferior que abrirá la ruta de la instalación en la aplicación de Google Maps de dispositivo móvil, el nombre de la instalación, su descripción y una serie de enlaces URL relacionados con esta. Cuando uno de los enlaces es seleccionado, se abrirá el navegador externo del dispositivo móvil con la dirección web del enlace.

 
\lstinputlisting[language=java, caption={Fichero \texttt{SiteDescriptionActivity.java}.}, label={lst:SiteDescriptionActivity.java},]{listings/SiteDescriptionActivity.java}
 
     
\section{Preferencias del usuario}

Se necesita un lugar donde el usuario pueda editar los ajustes de la aplicación. Para ellos se ha utilizado la clase heredable ``PrefenceActivity'' que ofrece Android para diseñar una ventana en la que poder editar de forma rápida e intuitiva los ajustes de una aplicación Android. Desde Android Studio se crea un ``PrefenceActivity'' con el nombre de ``SettingsULLActivity''. A continuación, se generará un activity que hereda de ``PrefenceActivity'' en el cual insertar la vista que contiene los ajustes de la aplicación. El fichero \texttt{pref\_nav\_setting.xml} (véase Listado \ref{lst:pref_nav_setting.xml}) contendrá la lista con los ajustes necesarios para la aplicación. Cada uno de estos ajustes pueden disponer, en función del tipo ajuste que se requiera, de un nombre, una descripción, una clave y un valor por defecto. Estos ajustes permitirán decidir al usuario si desea encontrar las instalaciones, en el mapa o en el modo realidad aumentada, dentro de dos circunferencias y la dimensiones en metros de ambos radios (véase Figura \ref{fig:settingsApp}).
 
\lstinputlisting[language=XML, caption={Fichero \texttt{pref\_nav\_setting.xml}.}, label={lst:pref_nav_setting.xml},]{listings/pref_nav_settings.xml}

Esta recurso de ventanas que ofrece Android para crear los ajustes de una aplicación, permite trabajar con las Shared Preferences para guardar los valores de los ajustes y poder acceder a ellos en otras ventanas de la aplicación. Cuando se edita un valor en la ventana de la aplicación, este valor se guardará automáticamente en las Shared Preferences con el valor de la clave ``key''. Esta clave servirá para poder acceder al valor a través de las Shared Preferences en cualquier activity.

% \lstinputlisting[language=java, caption={Fichero \texttt{SettingsULLActivity.java}.}, label={lst:SettingsULLActivity.java},]{listings/SettingsULLActivity.java}


\section{Back-end de la aplicación} \label{chap:BackEnd} 

Si se recuerda, en el capítulo \ref{chap:Tecnologias} se comentó sobre el uso de las tecnologías de Node.js y MongoDB, como servidor y base de datos respectivamente. Para poder implementar estas tecnologías se decidió por utilizar las plataformas PaaS en la nube para gestionarlos, facilitar su despliegue y con motivos de profundizar y adquirir conocimiento sobre las capacidades y ventajas de este tipo de plataformas. Estos plataformas son Heroku como servidor de la aplicación y mLab como base de datos. Ambos ofrecen una forma sencilla, accesible y escalable, para poder realizar las pruebas con la aplicación por las instalaciones de la ULL sin tener que montar un servidor físico.

\subsection{Base de datos}

Todos los datos necesarios para el funcionamiento de la aplicación estarán alojados en una base de datos en la nube. mLab será el proveedor de servicio escogido para alojar la base de datos. Este proveedor ofrece bases de datos NoSQL que utilizan la tecnología MongoDB.

Crear la base de datos es muy sencillo con mLab. Simplemente hay que registrarse y crear una base de datos. Lo primero que se necesita es elegir un plan de datos. Como en la base de datos que se necesita no es necesario mucho espacio de almacenamiento, se optó por el plan gratuito que dispone de 500 megas. Posteriormente se fija el nombre de la base de datos que será ``bd-ull-AR".

\subsection{Configuración del servidor}

Se necesita configurar el servidor de Node.js para poder desplegarlo en Heroku y que funcione correctamente. A continuación, se explicarán los pasos seguidos para la implementación del servidor explicando su funcionamiento y su conexión con la base de datos.

\subsubsection{Requisitos previos}
Para toda la instalación e implementación del servidor Node.js se ha utilizado Linux como sistema operativo.

Previo a la implementación se necesitará crear una cuenta en la plataforma de Heroku y en la de mLab. A su vez, se debe tener instalado GitHub, Node.js y Heroku. Para poder ejecutar los comandos que permitan creación y despliegue del servidor en la nube.

Dentro de la cuenta de Heroku, se crea un repositorio con el nombre de "server-ull-AR" que será el servidor de la aplicación en la nube.

\subsubsection{Instalación de Node.js en el repositorio}

Terminados de instalar todos los requisitos necesarios, ya se puede empezar a implementar el servidor de Node.js.

Con el siguiente comando, ya se tiene preparado el repositorio para empezar a trabajar:

\begin{lstlisting}
    $ git clone https://github.com/heroku/server-ull-AR.git
\end{lstlisting}

Para empezar a trabajar con Node.js se necesita ejecutar el siguiente comando dentro del repositorio:

\begin{lstlisting}
    $ npm init 
\end{lstlisting}

Este comando resulta en la creación de un archivo llamado \texttt{package.json}. Este fichero se utiliza para administrar los paquetes disponibles en el ``Node Package Manager'' que se instalan localmente en el repositorio.

A continuación, se instalarán los paquetes necesarios para funcionamiento del servidor Node.js. Estos son:

\begin{itemize}
    \item \textbf{ExpressJS}: Express es una infraestructura de aplicaciones web Node.js mínima y flexible que proporciona un conjunto sólido de características para las aplicaciones web y móviles.
    \item \textbf{mongoose}: Mongoose es una librería para trabajar MongoDB y Node.js.
    \item \textbf{bodyparser}: Se necesitará para manejar las peticiones de JSON.
    \item \textbf{node-restful}: Sirve para manejar las peticiones recibidas del servidor y conectarse con una base de datos de MongoDB.
\end{itemize}

Con un comando se instalarán todos los paquetes y se guardarán las dependencias utilizadas en el fichero \texttt{package.json}:

\begin{lstlisting}
    $ npm install --save express body-parser mongoose node-restful
\end{lstlisting}

El resultado del \texttt{package.json} sería el siguiente:

\lstset{numbers=left,  string=[s]{"}{"}, comment=[l]{:}, commentstyle=\color{black},}
\lstinputlisting[stringstyle=\color{blue}, caption={Contenido del fichero \texttt{package.json}.}, label={package.json}, ]{listings/package.json} %% LISTING

\subsubsection{Inicialización del servidor}

Una vez ya instalados todos los paquetes se crea el fichero \texttt{server.js} (véase Listado \ref{lst:servera.js})x    . Este fichero será el que inicie el servidor y contenga las variables que configuran el mismo. 

\lstset{keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{colString}\ttfamily,
stringstyle=\color{purple}\ttfamily,
morestring=[b]',
morestring=[b]"}

\begin{lstlisting}[ caption={Fichero  \texttt{servera.js}, configuración inicial del servidor.}, label={lst:servera.js}]
    // Se declaran los paquetes que se necesitan
    var express = require('express');  
    var app = express();  // Se inicia la app
    // Se pone en modo escucha la app
    app.listen(3000, function() {
        console.log("Express server listening on port 3000"
      });

\end{lstlisting}

Para comprobar que el servidor funciona correctamente, se utilizará el siguiente comando, que ejecutará el servidor en local en el puerto 3000.
\begin{lstlisting}
    $ node server.js
\end{lstlisting}

Más adelante se terminará de configurar este fichero. A continuación se explicará la estructura y organización del servidor.

\subsubsection{Estructura de la aplicación}

Dentro de la carpeta principal del repositorio se han de crear dos subdirectorios:

\begin{itemize}
    \item \textbf{models/}
    \item \textbf{routes/}
\end{itemize}

A continuación se creará el fichero \texttt{ullSites.js} (véase Listado \ref{code:ullSites.js})dentro de la carpeta de \textit{models/}. Este fichero contiene el modelo que conecta con la colección de la base de datos y maneja las respuestas, como se explicará más adelante.   

\lstinputlisting[language=JavaScript, caption={Fichero \texttt{ullSites.js}.}, label={code:ullSites.js},]{listings/ullSites.js} %% LISTING

Se necesitará una ruta por la cual el servidor responderá con la información que se solicite de la base de datos. Para ello en la carpeta \textit{routes/} se creará el fichero \texttt{api.js} (véase Listado \ref{lst:api.js}). Este fichero manejará las peticiones que lleguen al servidor a través de la ruta ``\textit{https://server\_url/api/}'' y se encargará principalmente de conectarse con la base de datos para responder a estas peticiones.

\lstinputlisting[language=JavaScript,caption={Fichero \texttt{api.js}.}, label={lst:api.js},]{listings/api.js} %% LISTING
 
En el caso de que se acceda a la ruta ``\textit{/api/ull-sites}'' del servidor con una petición ``HTTP'' de tipo ``GET'', se enviará una respuesta al cliente con toda la información de las instalaciones que se encuentran en la base de datos.

\subsubsection{Conexión con mLab}

Con la cuenta de mLab y base datos ya creada en mLab, solo se va a necesitar una URL para poder acceder a ella. Esta URL está disponible en la página principal de la base de datos en mLab y tiene el siguiente formato:

\begin{lstlisting}
    mongodb://<dbuser>:<dbpassword>@ds235181.mlab.com:35181/ull-AR
\end{lstlisting}

Donde ``dbuser'' es el usuario que se usó para crear la base de datos y ``dbpassword'' la contraseña. Para evitar que el usuario y contraseña queden expuestos públicamente en el repositorio, se utiliza una variable de entorno. En este caso hay que configurar la variable de entorno para que funcione en Heroku. Para hacerlo se necesita utilizar este comando en la terminal:

\begin{lstlisting}
    $heroku config:set PROD_MONGODB=mongodb://username:password@ds235181.mlab.com:35181/ull-AR
\end{lstlisting}

Posteriormente la variable ``PROD\_MONGODB" se utilizará para conectarse al base de datos una vez este desplegada en Heroku.

Solo se va a necesitar crear una colección para el proyecto. Para ello se accede a la base de datos en el navegador y se pincha en el botón de ``Add collection'' y se nombrará ``\textit{ull\_sites}''. Aquí se tiene la información de las instalaciones de la ULL, las cuales se añadirán manualmente desde la página de mLab.


\subsubsection{Configuración final del servidor}

Por último, se tiene que terminar de configurar el fichero \texttt{server.js} (véase Listado \ref{code:server.js})  que contiene el servidor. Se necesitará indicar al servidor la URL de la base de datos de mLab y de disponer que las rutas de la aplicación estén bien configuradas para responder a las solicitudes de \ULLAR{}. 

\lstinputlisting[language=JavaScript,caption={Configuración final del fichero \texttt{server.js}. }, label={code:server.js},]{listings/server.js} %% LISTING

\subsection{Despliegue en Heroku}

Terminada la implementación del servidor, se puede realizar el despliegue en Heroku. Para ello se necesitará crear un fichero \texttt{Procfile} (véase Listado \ref{lst:Procfile}) en la raíz del repositorio, que le dirá a Heroku cuál es el fichero que inicia el servidor.

\begin{lstlisting}[language=java, caption={Fichero \texttt{Procfile}.}, label={lst:Procfile},]
    web: node server.js
\end{lstlisting}

Para desplegarlo en Heroku se necesitarán estos tres comandos:

\begin{lstlisting}
    $ git add .
    $ git commit -m "Despliegue del servidor"
    $ git push heroku master
\end{lstlisting}

Con estos pasos completados ya se tiene el servidor desplegado y funcionando en la URL \cite{URL::servidorULLAR}.




